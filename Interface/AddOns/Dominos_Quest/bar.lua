local handler = CreateFrame("ScrollFrame", "ObjectiveHandler", UIParent)handler:SetPoint("TopLeft", MinimapCluster, "BottomLeft", -150, 0)handler:SetSize((175)*1.5, 420)function handler:InitializeController(parent, conf)	self:SetController(parent)	self:SetConfig(conf)    self:Initialize()    return selfendfunction handler:SetController(parent)	self:SetParent(parent)	self:ClearAllPoints()	self:SetPoint('TopLeft', 0, 0)	self:SetPoint('BottomRight', 0, 0)	self.parent = parentendfunction handler:SetConfig(conf)	self.sets = confendfunction handler:Initialize()    self:SnatchObjectiveTrackerFrame()    self:Hook_SetBlockHeader()    self:HookMinimizeButton()	self:InitializeScroll()	self:CreateMenu()    self:RegisterEvent("ZONE_CHANGED")    self:RegisterEvent("ZONE_CHANGED_NEW_AREA")    self:RegisterEvent("ZONE_CHANGED_INDOORS")    self:RegisterEvent("WORLD_MAP_UPDATE")    self:SetScript("OnEvent", handler.UpdateList)    self:AdjustHeight(0)    self:RepositionCollapse()    self:UpdateAlwaysShowAchievements()	return selfendfunction handler:SnatchObjectiveTrackerFrame()    --Take initial control of the ObjectiveTrackerFrame    self.tracker = ObjectiveTrackerFrame	self.tracker:SetParent(self)	self.tracker:SetMovable(true)	self.tracker:SetUserPlaced(true)	self.tracker:ClearAllPoints()	self:SetScrollChild(self.tracker)	self.tracker:SetPoint('TopLeft', 30, 0)	--self.tracker:SetHeight(2000)endfunction handler:HookMinimizeButton()    --Toggle display of quest. Leaves tracked Achievements(etc.) visible.	local mini = self.tracker.HeaderMenu.MinimizeButton	mini:ClearAllPoints()	mini:SetPoint("TopRight", self)	local minimizeHandler = CreateFrame("Frame", "QuestMinimizeButtonOverlay", mini)	minimizeHandler:SetParent(mini)	minimizeHandler:SetAllPoints(mini)	minimizeHandler:EnableMouse("AnyUp")		local dropDown = CreateFrame("Frame", "QuestFilterMenu", minimizeHandler, "UIDropDownMenuTemplate")	UIDropDownMenu_Initialize( dropDown, self.InitializeMenu, "MENU")		minimizeHandler:SetScript("OnMouseDown", function(self, button)		if button == "RightButton" then			ToggleDropDownMenu(1, 1, dropDown, minimizeHandler:GetName(), 0, -5)		else			mini:Click()			handler:UpdateCollapse()		end		--ObjectiveTracker_Update(OBJECTIVE_TRACKER_UPDATE_QUEST)	end)	self.mini = miniendfunction handler:Hook_SetBlockHeader()    --corrects bug where all quests display an extra empty line of text.	hooksecurefunc(QUEST_TRACKER_MODULE, "SetBlockHeader", function()	    self:RepositionTracker()		for i = 1, GetNumQuestWatches() do			local questID = GetQuestWatchInfo(i);			if ( questID ) then				local block = QUEST_TRACKER_MODULE:GetExistingBlock(questID);				if ( block ) then					for i, line in pairs(block.lines) do						line.Text:SetHeight(28)					end				end			end		end	 end)endfunction handler:CreateMenu()    --drop down menu for quick acces to all quest sorting options.	local quest = QUEST_TRACKER_MODULE.Headerendlocal menuTable = {    [1] = {        {            text = "Filter By Zone",            func = function() return handler:ToggleFilterByZone() end,            checked = function() return handler:GetFilterByZone() end,            keepShownOnClick = true,            dispCondition = function() return true end,        },        {            text = "Sort By Proximity",            func = function() return handler:ToggleSortByProximity() end,            checked = function() return handler:GetSortByProximity() end,            keepShownOnClick = true,            dispCondition = function() return true end,        },        {            text = "Enable Scrolling",            func = function() return handler:ToggleScroll() end,            checked = function() return handler:GetScroll() end,            keepShownOnClick = true,            dispCondition = function() return true end,        },        {            text = "Always Show Achievements",            func = function() return handler:ToggleAlwaysShowAchievements() end,            checked = function() return handler:GetAlwaysShowAchievements() end,            keepShownOnClick = true,            dispCondition = function() return true end,        },        {            text = "Buttons on Left",            func = function() return handler:ToggleAlignment() end,            checked = function() return handler:GetAlignment() end,            keepShownOnClick = true,            dispCondition = function() return true end,        },        {            text = "Collapse Down",            func = function() return handler:ToggleCollapse() end,            checked = function() return handler:GetCollapse() end,            keepShownOnClick = true,            dispCondition = function() return true end,        },        {            text = "Max Quests Displayed",            value = "max",            func = function() return end,            checked = function() return handler:GetMaxDisplayed() end,            keepShownOnClick = true,            displayMode = "MENU",            hasArrow = 1,            dispCondition = function() return true end,        },        {            text = "Adjust Height",            value = "height",            func = function() return handler:ToggleAlignment() end,            checked = function() return handler:GetAlignment() end,            keepShownOnClick = true,            displayMode = "MENU",            hasArrow = 1,            dispCondition = function() if not Dominos then return true end end,        },    },}local info = {}function handler:InitializeMenu(level, ...)	if level == 1 then        for i, inf in pairs(menuTable[level]) do            if inf.dispCondition() then                local info = UIDropDownMenu_CreateInfo()                for j, b in pairs(inf) do                    info[j] = b                end                UIDropDownMenu_AddButton(info)            end        end	elseif (level == 2) and UIDROPDOWNMENU_MENU_VALUE == "max" then		for i = 1, 25 do			local info = UIDropDownMenu_CreateInfo();			info.text = i;			info.func = function() handler:SetMaxDisplayed(i) print(i) end			info.checked = function() return (handler:GetMaxDisplayed() == i) end			UIDropDownMenu_AddButton(info, 2, "max");		end	elseif not Dominos then		local info = UIDropDownMenu_CreateInfo();		info.text = "+1";		info.func = function()		    handler:AdjustHeight(1)		end		info.notCheckable = true		info.keepShownOnClick  = true		UIDropDownMenu_AddButton(info, 2);		local info = UIDropDownMenu_CreateInfo();		info.text = "+5";		info.func = function()		    handler:AdjustHeight(5)		end		info.notCheckable = true		info.keepShownOnClick  = true		UIDropDownMenu_AddButton(info, 2);		local info = UIDropDownMenu_CreateInfo();		info.text = "+10";		info.func = function()		    handler:AdjustHeight(10)		end		info.notCheckable = true		info.keepShownOnClick  = true		UIDropDownMenu_AddButton(info, 2);		local info = UIDropDownMenu_CreateInfo();		info.text = "+50";		info.func = function()		    handler:AdjustHeight(50)		end		info.notCheckable = true		info.keepShownOnClick  = true		UIDropDownMenu_AddButton(info, 2);		local info = UIDropDownMenu_CreateInfo();		info.text = "-50";		info.func = function()		    handler:AdjustHeight(-50)		end		info.notCheckable = true		info.keepShownOnClick  = true		UIDropDownMenu_AddButton(info, 2);		local info = UIDropDownMenu_CreateInfo();		info.text = "-10";		info.func = function()		    handler:AdjustHeight(-10)		end		info.notCheckable = true		info.keepShownOnClick  = true		UIDropDownMenu_AddButton(info, 2);		local info = UIDropDownMenu_CreateInfo();		info.text = "-5";		info.func = function()		    handler:AdjustHeight(-5)		end		info.notCheckable = true		info.keepShownOnClick  = true		UIDropDownMenu_AddButton(info, 2);		local info = UIDropDownMenu_CreateInfo();		info.text = "-1";		info.func = function()		    handler:AdjustHeight(-1)		end		info.notCheckable = true		info.keepShownOnClick  = true		UIDropDownMenu_AddButton(info, 2);	endendlocal fauxAcheive = CreateFrame("Frame", nil, handler)fauxAcheive.header = CreateFrame("Button", "AchievementHeader", fauxAcheive, "ObjectiveTrackerHeaderTemplate")fauxAcheive.header:SetPoint("TopLeft", -9, 26)fauxAcheive.header:SetPoint("TopRight", -1, 26)fauxAcheive.header.Text:SetText(TRACKER_HEADER_ACHIEVEMENTS)fauxAcheive:SetPoint("BottomLeft", 30, 0)fauxAcheive:SetPoint("BottomRight")local newLine = [[ ]]local string = ""local function AddLine(line, text, lineType)    if lineType == "Header" then        string = string..text..newLine    else        string = string.. "|cFFFFFFFF"..text.."|r"..newLine    end    endlocal fontLines = {}local freeLines = {}local function FreeLine(i)    local line = fontLines[i]    line:Hide()    line.button:Hide()    line:SetText("")    line:ClearAllPoints()    tremove(fontLines, i)    tinsert(freeLines, line)endlocal function NewFontLine()    local line    if freeLines[1] then        line = freeLines[1]        tremove(freeLines, 1)    else        line = fauxAcheive:CreateFontString(nil, "OVERLAY", "GameFontNormal")        line:SetAlpha(.75)        line.button = CreateFrame("Button", nil, fauxAcheive)        line.button:SetPoint("TopLeft", line, 0, -6)        line.button:SetPoint("TopRight", line, 0, -6)        line.button:SetHeight(12)        line.button:RegisterForClicks("LeftButtonUp", "RightButtonUp")        line.button:SetScript("OnClick", function(self, mouseButton)            self.activeFrame = self            ACHIEVEMENT_TRACKER_MODULE:OnBlockHeaderClick(self, mouseButton)        end)        line.button:SetScript("OnEnter", function(self)            line:SetAlpha(1)        end)        line.button:SetScript("OnLeave", function(self)            line:SetAlpha(.75)        end)        line:SetSpacing(1)    end    line:Show()    line.button:Show()    line:SetJustifyH("LEFT")    tinsert(fontLines, line)    return lineendlocal function LayoutLines()    if #fontLines > 0 then        fauxAcheive.header:Show()    else        fauxAcheive.header:Hide()        fauxAcheive:SetHeight(0)    end    for i=1, #fontLines do        i = (#fontLines + 1) - i                local line = fontLines[i]        if i == #fontLines then            line:SetPoint("BottomLeft", handler, 30, 0)            line:SetPoint("BottomRight", handler)        else            line:SetPoint("BottomLeft", fontLines[i+1],"TopLeft", 0, -7)            line:SetPoint("BottomRight", fontLines[i+1],"TopRight", 0, -7)        end        if i == 1 then            fauxAcheive:SetPoint("Top", line, 0, 0)        end    endendlocal TIMED_CRITERIA = { };local ARENA_CATEGORY = 165;local MAX_CRITERIA_PER_ACHIEVEMENT = 5;local function GetAchievementBlockHeight()    while #fontLines > 0 do        FreeLine(1)    end    local text = ""    local trackedAchievements = { GetTrackedAchievements() };    numDisplayed = 0    for i = 1, #trackedAchievements do        local achievementID = trackedAchievements[i];        local id, achievementName, points, completed, month, day, year, description, flags, icon, rewardText, isGuild, wasEarnedByMe, earnedBy = GetAchievementInfo(achievementID);		-- check filters		local showAchievement = true;		if ( wasEarnedByMe ) then			showAchievement = false;		elseif ( displayOnlyArena ) then			if ( GetAchievementCategory(achievementID) ~= ARENA_CATEGORY ) then				showAchievement = false;			end		end		            if ( showAchievement ) then            local line = NewFontLine()            line.button.id = achievementID            numDisplayed = numDisplayed + 1            string = ""			--local block = ACHIEVEMENT_TRACKER_MODULE:GetBlock(achievementID);			--ACHIEVEMENT_TRACKER_MODULE:SetBlockHeader(block, achievementName);			local header = achievementName			--text = text..header..newLine			AddLine(line, header, "Header")			-- criteria			local numCriteria = GetAchievementNumCriteria(achievementID);			if ( numCriteria > 0 ) then				local numShownCriteria = 0;				for criteriaIndex = 1, numCriteria do					local criteriaString, criteriaType, criteriaCompleted, quantity, totalQuantity, name, flags, assetID, quantityString, criteriaID, eligible, duration, elapsed = GetAchievementCriteriaInfo(achievementID, criteriaIndex);								local colorStyle = eligible and OBJECTIVE_TRACKER_COLOR["Normal"] or OBJECTIVE_TRACKER_COLOR["Failed"];					if ( criteriaCompleted or ( numShownCriteria > MAX_CRITERIA_PER_ACHIEVEMENT and not criteriaCompleted ) ) then						-- Do not display this one					elseif ( numShownCriteria == MAX_CRITERIA_PER_ACHIEVEMENT and numCriteria > (MAX_CRITERIA_PER_ACHIEVEMENT + 1) ) then						-- We ran out of space to display incomplete criteria >_<						--ACHIEVEMENT_TRACKER_MODULE:AddObjective(block, "Extra", "...", nil, nil, true);												numShownCriteria = numShownCriteria + 1;					else						if ( description and bit.band(flags, EVALUATION_TREE_FLAG_PROGRESS_BAR) == EVALUATION_TREE_FLAG_PROGRESS_BAR ) then							-- progress bar							if ( string.find(strlower(quantityString), "interface\\moneyframe") ) then	-- no easy way of telling it's a money progress bar								criteriaString = quantityString.."\n"..description;							else								-- remove spaces so it matches the quest look, x/y								criteriaString = string.gsub(quantityString, " / ", "/").." "..description;							end						else							-- for meta criteria look up the achievement name							if ( criteriaType == CRITERIA_TYPE_ACHIEVEMENT and assetID ) then								_, criteriaString = GetAchievementInfo(assetID);							end						end						--local line = ACHIEVEMENT_TRACKER_MODULE:AddObjective(block, criteriaIndex, criteriaString, nil, nil, nil, colorStyle);						local line = criteriaString						--text = text.. "|cFFFFFFFF".."- "..line.."|r"..newLine									            AddLine(line, "- "..criteriaString, "Objective")						numShownCriteria = numShownCriteria + 1;						-- timer bar						if ( duration and elapsed and elapsed < duration ) then							--ACHIEVEMENT_TRACKER_MODULE:AddTimerBar(block, line, duration, GetTime() - elapsed);						elseif ( line.TimerBar ) then							--ACHIEVEMENT_TRACKER_MODULE:FreeTimerBar(block, line);						end											end				end            else				-- single criteria type of achievement				local colorStyle = IsAchievementEligible(achievementID) and OBJECTIVE_TRACKER_COLOR["Normal"] or OBJECTIVE_TRACKER_COLOR["Failed"];				--local line = ACHIEVEMENT_TRACKER_MODULE:AddObjective(block, 1, description, nil, nil, nil, colorStyle);				local line = description				                --text = text.. "|FF0000".."- "..line.."|"..newLine                                AddLine(line, "- "..description, "Objective")				-- check if we're supposed to show a timer bar for this				local timerShown = false;				for timedCriteriaID, timedCriteria in next, TIMED_CRITERIA do					if ( timedCriteria.achievementID == achievementID ) then						local elapsed = GetTime() - timedCriteria.startTime;						if ( elapsed <= timedCriteria.duration ) then							--ACHIEVEMENT_TRACKER_MODULE:AddTimerBar(block, line, timedCriteria.duration, timedCriteria.startTime);							timerShown = true;						end						break;					end				end				if ( not timerShown and line.TimerBar ) then					--ACHIEVEMENT_TRACKER_MODULE:FreeTimerBar(block, line);				end			end            line:SetText(string)        end    end    if #fontLines > numDisplayed then        while #fontLines > numDisplayed do            FreeLine(numDisplayed+1)        end    end    LayoutLines()    return heightendlocal fauxScroll = 0local MaxFauxfunction handler:Scroll(step)    if not handler:GetScroll() then        self:SetVerticalScroll(0)	    fauxScroll = 0	    self:UpdateList()	    return    end	if handler:GetAlwaysShowAchievements() then	    handler:SetFauxScroll(step)    else        self:SetScroll(self:GetVerticalScroll() + (50 * (step * -1)))    endendfunction handler:InitializeScroll()    --Enables use of scrolling!	self.maxRange = 1	local sets = self:GetSettings()	sets.scrollStep = sets.scrollStep or 50	self:SetScript("OnMouseWheel", function(self, step)	    self:Scroll(step)	end)	self:SetVerticalScroll(-1)	self:SetHorizontalScroll(-30)	self.tracker:HookScript("OnEvent", function()		self:SetScroll()	end)	self:SetScroll()endlocal function GetPoint(frame, point,...)    local width, height = frame:GetSize()    local w, h = width/2, height/2    local X, Y = frame:GetCenter()    if (not X) or (not Y) then        return    end    if point == "TopLeft" then        return X - w, Y + h    elseif point == "Top" then        return X, Y + h    elseif point == "TopRight" then        return X + w, Y + h    elseif point == "Right" then        return X + w, Y    elseif point == "BottomRight" then        return X + w, Y - h    elseif point == "Bottom" then        return X, Y - h    elseif point == "BottomLeft" then        return X - w, Y - h    elseif point == "Left" then        return X - w, Y    elseif point == "Center" then        return X, Y    elseif point == "Vertical" then        return nil, Y    elseif point == "Horizontal" then        return X    endendlocal questList = {}function handler:SetFauxScroll(step)    local numdisplayed = 11    local totalQuests = #questList    local min, max = 0, MaxFaux or (totalQuests - numdisplayed)    fauxScroll = fauxScroll - step    if (fauxScroll < min)then		fauxScroll = min	elseif fauxScroll > max then		fauxScroll = max 	end	if fauxScroll > totalQuests then	    fauxScroll = max	elseif totalQuests < numdisplayed then	    fauxScroll = 0	end	if (fauxScroll == max+1) or (fauxScroll == min-1) then	    self:SetScroll(self:GetVerticalScroll() + (50 * (step * -1)))	else        handler:UpdateList()    end    self:SetHorizontalScroll(-30)endfunction handler:SetScroll(value)	if not handler:GetScroll() then		return	end	fauxScroll = 0	value = value or (self:GetVerticalScroll())	local height = self:GetHeight()	ObjectiveTrackerBlocksFrame.contentsHeight = ObjectiveTrackerBlocksFrame.contentsHeight or self:GetHeight()	local min, max = -1, ceil(ObjectiveTrackerBlocksFrame.contentsHeight - height)	if max < min then		max = min	end	if (value < min)then		value = min	elseif value > max then		value = max 	end	self:SetVerticalScroll(value)	self:SetHorizontalScroll(-30)endfunction handler:UpdateItemButtons()    --allows item buttons to be displayed on left side of ObjectiveTrackerFrame	local onLeft = self:GetAlignment()	for i = 1, GetNumQuestWatches() do		local questID = GetQuestWatchInfo(i);		if ( questID ) then			local block = QUEST_TRACKER_MODULE:GetExistingBlock(questID);			if ( block ) then				if ( block.itemButton ) then					block.itemButton:ClearAllPoints()					if onLeft then						block.itemButton:SetPoint("TopLeft", block, -28, -17)					else						block.itemButton:SetPoint("TopRight", block, -2, -17)					end				end			end		end	end	endfunction handler:RepositionTracker()    if handler:GetAlwaysShowAchievements() then	    --Make the ObjectiveTrackerFrame display as normal.		self.tracker:ClearAllPoints()		self.tracker:SetPoint('TopLeft', self, 30, 0)		self.tracker:SetPoint('TopRight', self, 0, 0)		self.tracker:SetPoint('Bottom', fauxAcheive.header, "Top")		self.heightSet = nil		return	elseif not self.heightSet then	    --makes the ObjectiveTrackerFrame long enough to display ALL tracked quests with scrolling.		self.tracker:ClearAllPoints()		self.heightSet = true		self.tracker:SetPoint('TopLeft', self, 30, 0)		self.tracker:SetPoint('TopRight', self, 0, 0)	    self.tracker:SetHeight(2000)	end	self:UpdateItemButtons()endfunction handler:GetSettings()    --settings. plan to make a stand alone version of the handler.    if not self.sets then        Dom_Quest = Dom_Quest or {maxDisplayed = 25, scrollStep = 50, height = 550}    else            Dom_Quest = self.sets    end    return self.sets or Dom_Questendlocal maxDisplayed, filterByZone, proximitySort, enableScroll, onLeft, revCollapse, ShowAchievements= 25--defaultsdo  --Rewrite specific function used in the QUEST_TRACKER_MODULE to enable quest sorting.		local oldGetQuestWatchInfo = GetQuestWatchInfo	local function FilterQuests()	    local hasPoi	    local numQuests = GetNumQuestWatches()		if handler:GetFilterByZone() == true then            --checks current zone for zone specific quests.            --if no zone specific quests, we display all quests instead.			for i = 1, numQuests do				local _, _, _, _, _, _, _, _, _, _, _, _, _, isOnMap, hasLocalPOI = oldGetQuestWatchInfo(i)				if (isOnMap == true)  or (hasLocalPOI == true)then					hasPoi = true				end			end		end				wipe(questList)		local poximitySort = handler:GetSortByProximity()				for i = 1, numQuests do			local questInfo = {oldGetQuestWatchInfo(i)};			if poximitySort and questInfo[3] then			    questInfo.distance = GetDistanceSqToQuest(questInfo[3]) or 100000000			end			if (hasPoi) then				if (questInfo[14] == true) or ((questInfo[15] == true))then					tinsert(questList, questInfo)				end			else				tinsert(questList, questInfo)			end		end		if poximitySort then			table.sort(questList, function(a,b) if a.distance and b.distance then return a.distance < b.distance end end);		end		end		function GetQuestWatchInfo(i)        if i == 1 then            FilterQuests()        end        handler.currentDisplayed = 0		if (handler:GetQuestsHidden() ~= true) and ((i) <= handler:GetMaxDisplayed()) then		    local info = questList[i + fauxScroll]            if  handler:GetAlwaysShowAchievements() then        	             local I =i + fauxScroll                if I>1 then                    local id = oldGetQuestWatchInfo(I-1)                    if id then                        local block = QUEST_TRACKER_MODULE:GetExistingBlock(id);                        if block then                            local _, bBottom = GetPoint(block, "Bottom")                            local _, qBottom = GetPoint(handler, "Bottom")                                                    if (bBottom and qBottom) and (bBottom <= qBottom) then                                MaxFaux = i - 2                                return                            end                        end                    end                end	        end			if info then			    handler.currentDisplayed = handler.currentDisplayed				return unpack(info)			end		end    endendfunction handler:ToggleQuests()    self.hideQuests = not self.hideQuestsendfunction handler:GetQuestsHidden()    return self.hideQuestsendfunction handler:UpdateList()	ObjectiveTracker_Update()endfunction handler:GetMaxDisplayed()    local sets = self:GetSettings()    local disp 	if sets then		return Max_Faux or sets.maxDisplayed	else		return Max_Faux or maxDisplayed	endendfunction handler:SetMaxDisplayed(i)    local sets = self:GetSettings()	if sets then		sets.maxDisplayed = i or maxDisplayed	else		maxDisplayed = i	end	fauxScroll = 0	handler:UpdateList()endfunction handler:GetFilterByZone()    local sets = handler:GetSettings()	if sets then		return sets.filterByZone	else		return filterByZone	endendfunction handler:ToggleFilterByZone()    local sets = handler:GetSettings()	if sets then		sets.filterByZone = not sets.filterByZone	else		filterByZone = not filterByZone	end	handler:UpdateList()endfunction handler:GetSortByProximity()    local sets = handler:GetSettings()	if sets then		return sets.proximitySort	else		return proximitySort	endendfunction handler:ToggleSortByProximity()    local sets = handler:GetSettings()	if sets then		sets.proximitySort = not sets.proximitySort	else		proximitySort = not proximitySort	end	handler:UpdateList()endfunction handler:GetScroll()    local sets = handler:GetSettings()	if sets then		return sets.enableScroll	else		return enableScroll	endendfunction handler:ToggleScroll()    local sets = handler:GetSettings()	if sets then		sets.enableScroll = not sets.enableScroll	else		enableScroll = not enableScroll	end	handler:RepositionTracker()	handler:UpdateList()	 handler:Scroll(0)endfunction handler:GetAlignment()    local sets = handler:GetSettings()	if sets then		return sets.onLeft	else		return onLeft	endendfunction handler:ToggleAlignment()    local sets = handler:GetSettings()	if sets then		sets.onLeft = not sets.onLeft	else		onLeft = not onLeft	end	handler:UpdateItemButtons()endfunction handler:AdjustHeight(value)    value = value or 0    local sets = self:GetSettings()    sets.height = sets.height or 550    sets.height = sets.height + value    self:SetHeight(sets.height)endfunction handler:UpdateCollapse()    handler.miniClicked = not handler.miniClicked	handler:RepositionCollapse()endfunction handler:RepositionCollapse()	local mini = self.mini    mini:ClearAllPoints()    if self:GetCollapse() then	    fauxAcheive:Hide()	    if handler.miniClicked then	        mini:SetPoint("BottomRight", self)	    else	        mini:SetPoint("TopRight", self)            if handler:GetAlwaysShowAchievements() then	            fauxAcheive:Show()	        end	    end	else	    if handler:GetAlwaysShowAchievements() then	        fauxAcheive:Show()	    end	    mini:SetPoint("TopRight", self)    endendfunction handler:ToggleCollapse()    local sets = handler:GetSettings()	if sets then		sets.revCollapse = not sets.revCollapse	else		revCollapse = not revCollapse	end    self:RepositionCollapse()endfunction handler:GetCollapse()    local sets = handler:GetSettings()	if sets then		return sets.revCollapse	else		return revCollapse	endendlocal old_ACHIEVEMENT_TRACKER_MODUL_Update = ACHIEVEMENT_TRACKER_MODULE.Updatefunction handler:UpdateAlwaysShowAchievements()    if handler:GetAlwaysShowAchievements() then        ACHIEVEMENT_TRACKER_MODULE.Update = GetAchievementBlockHeight	local displayOnlyArena = ArenaEnemyFrames and ArenaEnemyFrames:IsShown() and (instanceType == "arena");	local trackedAchievements = { GetTrackedAchievements() };    for i = 1, #trackedAchievements do		local achievementID = trackedAchievements[i];		local _, achievementName, _, completed, _, _, _, description, _, icon, _, _, wasEarnedByMe = GetAchievementInfo(achievementID);		-- check filters		local showAchievement = true;		if ( wasEarnedByMe ) then			showAchievement = false;		elseif ( displayOnlyArena ) then			if ( GetAchievementCategory(achievementID) ~= ARENA_CATEGORY ) then				showAchievement = false;			end		end				if ( showAchievement ) then			local block = ACHIEVEMENT_TRACKER_MODULE:GetBlock(achievementID)			block:Hide()		end	end        GetAchievementBlockHeight()        fauxAcheive:Show()    else        ACHIEVEMENT_TRACKER_MODULE.Update = old_ACHIEVEMENT_TRACKER_MODUL_Update        fauxAcheive:Hide()    end    handler:RepositionTracker()    handler:UpdateList()endfunction handler:ToggleAlwaysShowAchievements()    local sets = handler:GetSettings()	if sets then		sets.ShowAchievements = not sets.ShowAchievements	else		ShowAchievements = not ShowAchievements	end	handler:UpdateAlwaysShowAchievements()endfunction handler:GetAlwaysShowAchievements()    local sets = handler:GetSettings()	if sets then		return sets.ShowAchievements	else		return ShowAchievements	endendif not Dominos then    handler:Initialize()        returnend	--[[ Globals ]]--local AddonName = ...local Addon = LibStub('AceAddon-3.0'):GetAddon("Dominos")local KeyBound = LibStub('LibKeyBound-1.0')--[[ Bar ]]--local QuestBar = Addon:CreateClass('Frame', Addon.Frame)QuestBar.master = Addon_G[...] = QuestBardo	local QuestLogController = QuestBar.master:NewModule('QuestLogBar', 'AceEvent-3.0')	function QuestLogController:Load()		self.bar = QuestBar:New()		self.bar:Layout()	end	function QuestLogController:Unload()		self:UnregisterAllEvents()		if self.bar then			self.bar:Free()		end	end	function QuestLogController:UpdateButtons()		if InCombatLockdown() then return end		self.bar:UpdateButtons()	end	function QuestBar:New()		local frame = QuestBar.proto.New(self, 'quest')			frame.sets.maxDisplayed = frame.sets.maxDisplayed or 25		frame.scroll = handler:InitializeController(frame, frame.sets)		return frame	end	function QuestBar:Layout()		local w, h = ObjectiveTrackerFrame:GetSize()		local pad = self:GetPadding()		self:SetSize((175+pad)*1.5, (self.sets.height+pad)*1.5)		self.sets.scrollStep = self.sets.scrollStep or 50		self.scroll:ClearAllPoints()		self.scroll:SetPoint("Center")		self.scroll:SetSize((175)*1.5, (self.sets.height)*1.5)		self.scroll:RepositionTracker()				self.scroll:RepositionCollapse()		self.scroll:UpdateAlwaysShowAchievements()	end	function QuestBar:SetMaxDisplayed(value)		self.sets.maxDisplayed = value		handler:UpdateList()	end		function QuestBar:SetFilterByZone(enable)		self.sets.filterByZone = enable or nil		handler:UpdateList()	end	function QuestBar:SetSortByProximity(enable)		self.sets.proximitySort = enable or nil		handler:UpdateList()	end	function QuestBar:onLeft(enable)		self.sets.onLeft = enable or nil		self.scroll:RepositionTracker()	end	function QuestBar:revCollapse(enable)		self.sets.revCollapse = enable or nil		self.scroll:RepositionCollapse()	end			function QuestBar:enableScroll(enable)		self.sets.enableScroll = enable or nil		self.scroll:RepositionTracker()	end			function QuestBar:ShowAchievements(enable)		self.sets.ShowAchievements = enable or nil		self.scroll:UpdateAlwaysShowAchievements()	end		function QuestBar:GetDefaults()		return {			point = 'TopRight',			spacing = 0,			x = 0,			y = -200,			width = 232,			height = 420,			scrollStep = 50,			enableScroll = true,			pad = 0,			maxDisplayed = 25,		}	end	local L	local function AddQuestPanel(menu)		local panel = menu:NewPanel("Quests")		        local c = panel:NewCheckButton{            name = "Zone Filter",            get = function() return panel.owner.sets.filterByZone end,            set = function(self, enable)                panel.owner:SetFilterByZone(self:GetChecked())			            end        }        local c = panel:NewCheckButton{            name = "Sort By Proximity",            get = function() return panel.owner.sets.proximitySort end,            set = function(self, enable)                panel.owner:SetSortByProximity(self:GetChecked())			            end        }        local c = panel:NewCheckButton{            name = "Buttons on Left",            get = function() return panel.owner.sets.onLeft end,            set = function(self, enable)                panel.owner:onLeft(self:GetChecked())			            end        }            local c = panel:NewCheckButton{            name = "Collapse Down",            get = function() return panel.owner.sets.revCollapse end,            set = function(self, enable)                panel.owner:revCollapse(self:GetChecked())			            end        }        local c = panel:NewCheckButton{            name = "Enable Scroll",            get = function() return panel.owner.sets.enableScroll end,            set = function(self, enable)                panel.owner:enableScroll(self:GetChecked())			            end        }        local c = panel:NewCheckButton{            name = "Always Show Achievements",            get = function() return panel.owner.sets.ShowAchievements end,            set = function(self, enable)                panel.owner:ShowAchievements(self:GetChecked())			            end        }        local slider =  panel:NewSlider{            name = 'Max Quests',            min = 1,            max = 25,            get = function(self) --Getter                return panel.owner.sets.maxDisplayed            end,            set = function(self) --Setter                local owner = panel.owner                owner.sets.maxDisplayed = self:GetValue()                owner:Layout()                return owner.sets.maxDisplayed            end,        }		        local slider =  panel:NewSlider{            name = 'Scroll Speed',            min = 1,            max = 250,            get = function(self) --Getter                return panel.owner.sets.scrollStep            end,            set = function(self) --Setter                local owner = panel.owner                owner.sets.scrollStep = self:GetValue()                owner:Layout()                return owner.sets.scrollStep            end,        }	end	local function AddLayoutPanel(menu)		local panel = menu:NewPanel(L.Layout)		panel.scaleSlider = panel:NewScaleSlider()        local slider =  panel:NewSlider({            name = 'Height',            min = 250,            max = 500,            get = function(self) --Getter                return panel.owner.sets.height            end,            set = function(self) --Setter                local owner = panel.owner                owner.sets.height = self:GetValue()                owner:Layout()                return owner.sets.height            end,        })		panel.paddingSlider = panel:NewPaddingSlider()		panel.opacitySlider = panel:NewOpacitySlider()		panel.fadeSlider = panel:NewFadeSlider()				--[[        local slider =  panel:NewSlider({            name = 'Width',            min = 75,            max = 250,            get = function(self) --Getter                return panel.owner.sets.width            end,            set = function(self) --Setter                local owner = panel.owner                owner.sets.width = self:GetValue()                owner:Layout()                return owner.sets.width            end,        })--]]		return panel	end		local function AddShowState(self)        local p = self:NewPanel(L.ShowStates)            p.showStatesEditBox = p:NewTextInput{            name = L.ShowStates,            multiline = true,            width = 290,            height = 64,            get = function() return p.owner:GetShowStates() end,            set = function(self, value) p.owner:SetShowStates(value)end        }		return p	end		local function AddAdvancedPanel(menu)		local panel = menu:NewPanel(L.Advanced)		panel:NewClickThroughCheckbox()		panel:NewShowInOverrideUICheckbox()		panel:NewShowInPetBattleUICheckbox()		return panel	end		function QuestBar:CreateMenu()		local menu = Dominos:NewMenu(self.id)		L = LibStub('AceLocale-3.0'):GetLocale('Dominos-Config')			AddLayoutPanel(menu)		AddQuestPanel(menu)--		AddShowState(menu)		if self.components then			for i, b in pairs(self.components) do				if b.CreateMenu and QuestBar.Menu then					b:CreateMenu(menu)				end			end		end			AddAdvancedPanel(menu)		return menu	end			local menu, config	function QuestBar:ShowMenu()		if not QuestBar.master:IsConfigAddonEnabled() then return end		config = config or LoadAddOn('Dominos_Config')		L = L or LibStub('AceLocale-3.0'):GetLocale('Dominos-Config')		QuestBar.menu = QuestBar.menu or self:CreateMenu()			local menu = QuestBar.menu		menu:Hide()		menu:SetOwner(self)		menu:ShowPanel(L.Layout)		menu:Show()	endend